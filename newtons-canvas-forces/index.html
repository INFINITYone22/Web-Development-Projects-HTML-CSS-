<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Canvas - Forces</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg-start: #e0e7ff; /* Light lavender */
            --bg-end: #e0f2f7;   /* Light cyan */
            --accent-color: #4fd1c5; /* Gentle Teal */
            --accent-color-rgb: 79, 209, 197; /* RGB for rgba */
            --force-color-rgb: 79, 209, 197; /* Breeze/Attractor color */
            --object-color-light: #cccccc;
            --object-color-medium: #a0a0a0;
            --object-color-dark: #777777;
            --text-color: #4a5568;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --glow-color: rgba(var(--accent-color-rgb), 0.6); /* Teal glow */
            --constraint-color: rgba(var(--accent-color-rgb), 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(45deg, var(--bg-start), var(--bg-end));
            background-size: 400% 400%;
            animation: gradientShift 20s ease infinite;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
            cursor: default;
        }
        body.drawing-constraint,
        body.using-breeze-tool,
        body.using-attractor-tool {
             cursor: crosshair;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #physicsCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* --- UI Panel --- */
        #uiPanel {
            position: fixed;
            left: 10px;
            top: 50%;
            transform: translateY(-50%) translateX(-100%);
            padding: 15px 10px;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px) saturate(180%);
            -webkit-backdrop-filter: blur(10px) saturate(180%);
            border-radius: 0 12px 12px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        body:hover #uiPanel,
        #uiPanel:hover,
        #uiPanel:focus-within {
            transform: translateY(-50%) translateX(0);
        }

        .ui-button {
            background-color: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(200, 200, 200, 0.4);
            color: var(--text-color);
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease; /* Smoother transitions */
            width: 36px;
            height: 36px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            position: relative; /* For potential sub-menus */
        }

        .ui-button:hover {
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 6px var(--shadow-color);
        }

        .ui-button:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.9);
        }

        .ui-button.active {
             background-color: rgba(var(--accent-color-rgb), 0.2);
             border-color: var(--accent-color);
             box-shadow: 0 0 8px var(--glow-color);
        }

        /* --- Sub-Panel Styling (Example for Gravity) --- */
        .sub-panel {
            position: absolute;
            left: 110%; /* Position next to the button */
            top: 0;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px) saturate(150%);
            -webkit-backdrop-filter: blur(8px) saturate(150%);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 8px;
            width: 150px; /* Adjust width as needed */
            opacity: 0;
            transform: translateX(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 11; /* Above main panel */
        }

        .ui-button.active .sub-panel { /* Show when parent button is active */
            display: flex;
            opacity: 1;
            transform: translateX(0);
        }

        .sub-panel label {
            font-size: 11px;
            color: var(--text-color);
            opacity: 0.8;
            margin-bottom: -5px; /* Tighten spacing */
        }
        .sub-panel input[type="range"] {
             width: 100%;
             height: 4px;
             cursor: pointer;
             accent-color: var(--accent-color); /* Style the slider track/thumb */
        }
        /* Basic direction input styling */
        #gravityDirection {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 50%;
            margin: 5px auto;
            position: relative;
            cursor: pointer;
            background-color: rgba(0,0,0,0.05);
        }
        #gravityHandle {
            width: 8px;
            height: 8px;
            background-color: var(--accent-color);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center initially */
            pointer-events: none; /* Don't block clicks on the container */
        }


        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
             -webkit-backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            z-index: 5;
            opacity: 1;
            transition: opacity 0.5s ease 2s;
            pointer-events: none;
        }
        #instructions.hidden { opacity: 0; }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #uiPanel {
                left: 50%;
                top: auto;
                bottom: 10px;
                transform: translateX(-50%) translateY(100%);
                flex-direction: row;
                border-radius: 12px 12px 0 0;
                padding: 10px 15px;
            }

            body:hover #uiPanel,
            #uiPanel:hover,
            #uiPanel:focus-within {
                 transform: translateX(-50%) translateY(0);
            }

            .sub-panel {
                left: 50%;
                bottom: 110%; /* Position above the button */
                top: auto;
                transform: translateX(-50%) translateY(10px); /* Start slightly below */
            }
             .ui-button.active .sub-panel {
                 transform: translateX(-50%) translateY(0);
             }


             #instructions {
                 font-size: 12px;
                 padding: 8px 15px;
                 max-width: 90%;
             }
        }

    </style>
</head>
<body>

    <canvas id="physicsCanvas"></canvas>

    <div id="uiPanel" aria-label="Controls">
        <button class="ui-button" id="addCircle" title="Add Circle">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>
        </button>
        <button class="ui-button" id="addSquare" title="Add Square">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
        </button>
        <button class="ui-button tool-button" data-tool="constraint" id="addConstraint" title="Add Spring Constraint">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>
        </button>
        <button class="ui-button tool-button" data-tool="gravity" id="gravityControl" title="Gravity Control">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M3 12h18"/></svg> <div class="sub-panel" id="gravitySubPanel">
                 <label for="gravityStrength">Strength</label>
                 <input type="range" id="gravityStrength" min="0" max="2" step="0.1" value="1">
                 <label>Direction</label>
                 <div id="gravityDirection">
                     <div id="gravityHandle"></div>
                 </div>
             </div>
         </button>
         <button class="ui-button tool-button" data-tool="breeze" id="breezeTool" title="Breeze Tool">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/></svg>
         </button>
         <button class="ui-button tool-button" data-tool="attractor" id="attractorTool" title="Attractor/Repulsor Tool">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 16.5A4.5 4.5 0 1 0 7.5 12"></path><path d="M12 7.5A4.5 4.5 0 1 1 16.5 12"></path></svg> </button>
         <button class="ui-button" id="clearCanvas" title="Clear Canvas">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        </button>
    </div>

    <div id="instructions">
        Experiment with forces and constraints. Hover edge for controls.
    </div>

    <script>
        // --- Matter.js Module Aliases ---
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const Runner = Matter.Runner;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Composite = Matter.Composite;
        const Composites = Matter.Composites;
        const Constraint = Matter.Constraint;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Events = Matter.Events;
        const Query = Matter.Query;
        const Vector = Matter.Vector; // Need Vector for calculations
        const World = Matter.World;

        // --- Global Variables ---
        let engine;
        let world;
        let runner;
        let mouseConstraint;
        let canvas;
        let ctx;
        let walls = [];

        // Collision Glows
        let activeCollisions = [];
        const GLOW_DURATION = 300;
        const MAX_GLOW_RADIUS = 25;

        // Tool State
        let activeTool = null; // 'constraint', 'gravity', 'breeze', 'attractor', null
        let currentMousePos = { x: 0, y: 0 };

        // Constraint Drawing State
        let constraintStartBody = null;
        let constraintStartPoint = null;

        // Breeze Tool State
        let breezeStartPos = null;
        let activeBreezeVectors = []; // Store { start, end, strength, timestamp }
        const BREEZE_FADE_DURATION = 500; // ms
        const BREEZE_FORCE_MULTIPLIER = 0.0005; // Adjust force strength

        // Attractor Tool State
        let attractors = []; // Store { x, y, strength, isRepulsor, id }
        const ATTRACTOR_STRENGTH = 0.3; // Adjust force strength
        const ATTRACTOR_PULSE_SPEED = 0.03;
        const ATTRACTOR_MAX_RADIUS = 15;
        const ATTRACTOR_MIN_RADIUS = 8;

        // Gravity Direction State
        let isDraggingGravity = false;

        // --- Initialization ---
        function setup() {
            engine = Engine.create();
            world = engine.world;
            engine.gravity.y = 1; // Default gravity scale
            engine.gravity.x = 0;

            canvas = document.getElementById('physicsCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            createWalls();

            runner = Runner.create();

            // Setup Mouse Constraint (initially enabled)
            const mouse = Mouse.create(canvas);
            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Composite.add(world, mouseConstraint);

            // Event Listeners
            window.addEventListener('resize', handleResize);
            document.getElementById('addCircle').addEventListener('click', addCircle);
            document.getElementById('addSquare').addEventListener('click', addSquare);
            document.getElementById('clearCanvas').addEventListener('click', clearCanvas);

            // Tool Buttons
            document.querySelectorAll('.tool-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const toolName = button.dataset.tool;
                    setActiveTool(toolName);
                });
            });

            // Gravity Controls
            document.getElementById('gravityStrength').addEventListener('input', updateGravityScale);
            setupGravityDirectionControl();


            // Collision Listener
            Events.on(engine, 'collisionStart', handleCollisionStart);
            // Apply forces before each physics update
            Events.on(engine, 'beforeUpdate', applyCustomForces);

            // General Mouse Listeners (for tools)
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Hide instructions
            setTimeout(() => {
                document.getElementById('instructions').classList.add('hidden');
            }, 4000);

            Runner.run(runner, engine);
            requestAnimationFrame(renderLoop);
        }

        // --- Tool Activation ---
        function setActiveTool(toolName) {
            const previouslyActiveTool = activeTool;
            const clickedButton = document.querySelector(`.tool-button[data-tool="${toolName}"]`);
            const activeButton = document.querySelector('.tool-button.active');

            // Deactivate current tool if clicking the same button or a different one
            if (activeButton) {
                activeButton.classList.remove('active');
                document.body.classList.remove(`using-${activeButton.dataset.tool}-tool`);
                activeTool = null;
                // Reset specific tool states if needed when switching
                resetToolStates(activeButton.dataset.tool);
            }

            // Activate the new tool ONLY if it wasn't the one just deactivated
            if (clickedButton && previouslyActiveTool !== toolName) {
                activeTool = toolName;
                clickedButton.classList.add('active');
                document.body.classList.add(`using-${activeTool}-tool`);
            }

            // Enable/disable mouse constraint based on active tool
             updateMouseConstraintActivation();
        }

        function resetToolStates(toolName) {
            if (toolName === 'constraint') {
                constraintStartBody = null;
                constraintStartPoint = null;
            } else if (toolName === 'breeze') {
                breezeStartPos = null;
            }
            // No specific reset needed for gravity/attractor when toggling button off
        }

         function updateMouseConstraintActivation() {
             if (activeTool === 'constraint' || activeTool === 'breeze' || activeTool === 'attractor') {
                 // Disable mouse constraint for dragging bodies when a tool is active
                 mouseConstraint.collisionFilter.mask = 0;
             } else {
                 // Re-enable mouse constraint
                 mouseConstraint.collisionFilter.mask = 0xFFFFFFFF;
             }
         }


        // --- Gravity Controls ---
        function updateGravityScale(event) {
            engine.gravity.scale = parseFloat(event.target.value);
        }

        function setupGravityDirectionControl() {
            const directionInput = document.getElementById('gravityDirection');
            const handle = document.getElementById('gravityHandle');
            const radius = directionInput.offsetWidth / 2 - handle.offsetWidth / 2; // Radius for handle movement

            const updateGravityFromHandle = (x, y) => {
                const rect = directionInput.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let dx = x - centerX;
                let dy = y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Normalize and clamp distance
                if (dist > radius) {
                    dx = (dx / dist) * radius;
                    dy = (dy / dist) * radius;
                }

                // Update handle position
                handle.style.left = `${rect.width / 2 + dx}px`;
                handle.style.top = `${rect.height / 2 + dy}px`;

                // Update engine gravity vector (normalize dx, dy)
                 const normDist = Math.sqrt(dx * dx + dy * dy);
                 if (normDist > 0.1) { // Avoid zero vector
                     engine.gravity.x = dx / radius; // Map handle position directly to gravity vector components
                     engine.gravity.y = dy / radius;
                 } else {
                      engine.gravity.x = 0;
                      engine.gravity.y = 0; // Set to zero if handle is near center
                 }
            };

            directionInput.addEventListener('mousedown', (e) => {
                isDraggingGravity = true;
                updateGravityFromHandle(e.clientX, e.clientY);
                // Prevent canvas mouse down from firing
                e.stopPropagation();
            });

            window.addEventListener('mousemove', (e) => {
                if (isDraggingGravity) {
                    updateGravityFromHandle(e.clientX, e.clientY);
                }
            });

            window.addEventListener('mouseup', () => {
                isDraggingGravity = false;
            });

             // Initialize handle position based on default gravity
             const initialAngle = Math.atan2(engine.gravity.y, engine.gravity.x);
             const initialDist = Math.min(radius, radius * Math.sqrt(engine.gravity.x**2 + engine.gravity.y**2)); // Scale distance if gravity scale != 1 initially? No, map vector directly.
             handle.style.left = `${directionInput.offsetWidth / 2 + Math.cos(initialAngle) * radius}px`;
             handle.style.top = `${directionInput.offsetHeight / 2 + Math.sin(initialAngle) * radius}px`;
        }


        // --- Canvas and World Setup ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        function createWalls() {
            Composite.remove(world, walls); // Remove old walls first
            const wallOptions = { isStatic: true, restitution: 0.8, friction: 0.1, render: { visible: false } };
            const thickness = 120;
            walls = [
                Bodies.rectangle(canvas.width / 2, -thickness / 2, canvas.width + thickness*2, thickness, wallOptions), // Top
                Bodies.rectangle(canvas.width / 2, canvas.height + thickness / 2, canvas.width + thickness*2, thickness, wallOptions), // Bottom
                Bodies.rectangle(-thickness / 2, canvas.height / 2, thickness, canvas.height + thickness*2, wallOptions), // Left
                Bodies.rectangle(canvas.width + thickness / 2, canvas.height / 2, thickness, canvas.height + thickness*2, wallOptions) // Right
            ];
            Composite.add(world, walls);
        }
        function handleResize() { resizeCanvas(); createWalls(); }

        // --- Object Creation & Removal ---
        function addBody(body) { Composite.add(world, body); }
        function addCircle() { /* ... (same as before) ... */
             const radius = 20 + Math.random() * 20;
             const x = canvas.width * 0.2 + Math.random() * canvas.width * 0.6;
             const y = 50 + Math.random() * 50;
             const circle = Bodies.circle(x, y, radius, {
                 restitution: 0.7, friction: 0.3,
                 renderProps: { type: 'circle', fillStyle: getRandomGrey(), strokeStyle: '#555', lineWidth: 1, shadowColor: 'rgba(0, 0, 0, 0.2)', shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2 }
             });
             addBody(circle);
        }
        function addSquare() { /* ... (same as before) ... */
             const size = 30 + Math.random() * 30;
             const x = canvas.width * 0.2 + Math.random() * canvas.width * 0.6;
             const y = 50 + Math.random() * 50;
             const box = Bodies.rectangle(x, y, size, size, {
                 restitution: 0.6, friction: 0.4, chamfer: { radius: 4 },
                 renderProps: { type: 'rectangle', fillStyle: getRandomGrey(), strokeStyle: '#555', lineWidth: 1, shadowColor: 'rgba(0, 0, 0, 0.2)', shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2 }
             });
             addBody(box);
        }
        function clearCanvas() { /* ... (same as before, also remove attractors) ... */
             const allBodies = Composite.allBodies(world);
             allBodies.forEach(body => { if (!body.isStatic) Composite.remove(world, body); });
             const allConstraints = Composite.allConstraints(world);
             allConstraints.forEach(constraint => { if (constraint !== mouseConstraint.constraint) Composite.remove(world, constraint); });
             activeCollisions = [];
             attractors = []; // Clear attractors
             activeBreezeVectors = []; // Clear active breeze lines
        }

        // --- Mouse Handlers for Tools ---
        function handleMouseDown(event) {
            currentMousePos = { x: event.clientX, y: event.clientY }; // Update position

            if (activeTool === 'constraint') {
                // Find body under mouse
                const bodiesUnderMouse = Query.point(Composite.allBodies(world), currentMousePos);
                let clickedBody = bodiesUnderMouse.find(body => !body.isStatic);

                if (clickedBody) {
                    constraintStartBody = clickedBody;
                    // Calculate local offset
                    const dx = currentMousePos.x - constraintStartBody.position.x;
                    const dy = currentMousePos.y - constraintStartBody.position.y;
                    const angle = constraintStartBody.angle;
                    constraintStartPoint = {
                         x: dx * Math.cos(-angle) - dy * Math.sin(-angle),
                         y: dx * Math.sin(-angle) + dy * Math.cos(-angle)
                    };
                }
            } else if (activeTool === 'breeze') {
                breezeStartPos = { x: currentMousePos.x, y: currentMousePos.y };
            } else if (activeTool === 'attractor') {
                 // Check if clicking on existing attractor to remove it
                 let clickedExisting = false;
                 for (let i = attractors.length - 1; i >= 0; i--) {
                     const dist = Vector.magnitude(Vector.sub(currentMousePos, attractors[i]));
                     if (dist < ATTRACTOR_MAX_RADIUS) { // Clicked near an existing one
                         attractors.splice(i, 1);
                         clickedExisting = true;
                         break;
                     }
                 }
                 // If not clicking existing, add a new one
                 if (!clickedExisting) {
                     attractors.push({
                         x: currentMousePos.x,
                         y: currentMousePos.y,
                         strength: ATTRACTOR_STRENGTH,
                         isRepulsor: false, // Add toggle later
                         id: Date.now() + Math.random(), // Unique ID
                         pulsePhase: Math.random() * Math.PI * 2 // Random start phase
                     });
                 }
            }
            // If no tool active, mouseConstraint handles dragging (if enabled)
        }

        function handleMouseMove(event) {
            currentMousePos = { x: event.clientX, y: event.clientY };
            // Visual feedback for constraint/breeze drawing happens in renderLoop
        }

        function handleMouseUp(event) {
            currentMousePos = { x: event.clientX, y: event.clientY }; // Update position

            if (activeTool === 'constraint' && constraintStartBody) {
                // Find end body
                const bodiesUnderMouse = Query.point(Composite.allBodies(world), currentMousePos);
                let endBody = bodiesUnderMouse.find(body => !body.isStatic && body !== constraintStartBody);

                if (endBody) {
                    // Calculate local offset for end body
                    const dx = currentMousePos.x - endBody.position.x;
                    const dy = currentMousePos.y - endBody.position.y;
                    const angle = endBody.angle;
                    const endPoint = {
                        x: dx * Math.cos(-angle) - dy * Math.sin(-angle),
                        y: dx * Math.sin(-angle) + dy * Math.cos(-angle)
                    };
                    // Create constraint
                    const constraint = Constraint.create({
                        bodyA: constraintStartBody, pointA: constraintStartPoint,
                        bodyB: endBody, pointB: endPoint,
                        stiffness: 0.02, damping: 0.05,
                        render: { strokeStyle: `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--accent-color-rgb')}, 0.7)`, lineWidth: 2 }
                    });
                    Composite.add(world, constraint);
                }
                // Reset constraint drawing state
                constraintStartBody = null;
                constraintStartPoint = null;
            } else if (activeTool === 'breeze' && breezeStartPos) {
                const dx = currentMousePos.x - breezeStartPos.x;
                const dy = currentMousePos.y - breezeStartPos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10) { // Only add if dragged a minimum distance
                    activeBreezeVectors.push({
                        start: { ...breezeStartPos },
                        end: { ...currentMousePos },
                        strength: dist * BREEZE_FORCE_MULTIPLIER,
                        timestamp: performance.now()
                    });
                }
                breezeStartPos = null; // Reset breeze start position
            }
            // No specific action needed for attractor on mouse up
        }


        // --- Apply Custom Forces ---
        function applyCustomForces(event) {
             const bodies = Composite.allBodies(world);
             const time = performance.now();

             // Apply Attractor/Repulsor Forces
             attractors.forEach(attractor => {
                 bodies.forEach(body => {
                     if (body.isStatic) return;
                     const direction = Vector.sub(attractor, body.position);
                     const distanceSq = Vector.magnitudeSquared(direction);
                     if (distanceSq < 1) return; // Avoid extreme forces at close range

                     // Force proportional to 1/distance (or 1/distance^2 for more realism)
                     const forceMagnitude = attractor.strength * body.mass / distanceSq; // Gravity-like falloff
                     const force = Vector.mult(Vector.normalise(direction), forceMagnitude);

                     Body.applyForce(body, body.position, attractor.isRepulsor ? Vector.neg(force) : force);
                 });
             });

             // Apply Breeze Forces (from recently drawn lines)
             activeBreezeVectors.forEach(breeze => {
                 const age = time - breeze.timestamp;
                 if (age > BREEZE_FADE_DURATION) return; // Skip faded breezes

                 const breezeVector = Vector.sub(breeze.end, breeze.start);
                 if (Vector.magnitudeSquared(breezeVector) < 1) return; // Skip zero-length breezes

                 const normalizedBreeze = Vector.normalise(breezeVector);
                 const forceMagnitude = breeze.strength * (1 - age / BREEZE_FADE_DURATION); // Fade force over time

                 bodies.forEach(body => {
                     if (body.isStatic) return;
                     // Simple check: Apply if body is roughly within the area swept by the line
                     // A more robust check would use line segment intersection or bounding box checks
                     const bodyToStart = Vector.sub(body.position, breeze.start);
                     const proj = Vector.dot(bodyToStart, normalizedBreeze);
                     // Check if projection is within line segment length and perpendicular distance is small enough
                     if (proj >= 0 && proj <= Vector.magnitude(breezeVector)) {
                          const perpDist = Vector.magnitude(Vector.sub(bodyToStart, Vector.mult(normalizedBreeze, proj)));
                          if (perpDist < 50) { // Apply force if body is within 50px perpendicular distance
                              Body.applyForce(body, body.position, Vector.mult(normalizedBreeze, forceMagnitude * body.mass)); // Force proportional to mass
                          }
                     }
                 });
             });
             // Clean up faded breeze vectors
             activeBreezeVectors = activeBreezeVectors.filter(b => (time - b.timestamp) <= BREEZE_FADE_DURATION);
        }


        // --- Collision Handling ---
        function handleCollisionStart(event) { /* ... (same as before) ... */
             const pairs = event.pairs;
             const timestamp = performance.now();
             for (let i = 0; i < pairs.length; i++) {
                 const pair = pairs[i];
                 if (pair.bodyA.isStatic || pair.bodyB.isStatic) continue;
                 let collisionX = 0, collisionY = 0;
                 if (pair.activeContacts && pair.activeContacts.length > 0) {
                     pair.activeContacts.forEach(contact => { collisionX += contact.vertex.x; collisionY += contact.vertex.y; });
                     collisionX /= pair.activeContacts.length; collisionY /= pair.activeContacts.length;
                     activeCollisions.push({ x: collisionX, y: collisionY, startTime: timestamp });
                 }
             }
        }

        // --- Helper Functions ---
        function getRandomGrey() { /* ... (same as before) ... */
             const shades = ['#cccccc', '#b0b0b0', '#a0a0a0', '#909090', '#777777'];
             return shades[Math.floor(Math.random() * shades.length)];
        }

        // --- Custom Rendering Loop ---
        function renderLoop() {
            const timestamp = performance.now();
            const allBodies = Composite.allBodies(world);
            const allConstraints = Composite.allConstraints(world);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Render Constraints (same as before)
            ctx.beginPath();
            for (let i = 0; i < allConstraints.length; i++) {
                 const constraint = allConstraints[i];
                 if (constraint === mouseConstraint.constraint) continue;
                 const bodyA = constraint.bodyA, bodyB = constraint.bodyB;
                 const pointA = constraint.pointA, pointB = constraint.pointB;
                 let startPos, endPos;
                 if (bodyA) startPos = { x: bodyA.position.x + (pointA.x * Math.cos(bodyA.angle) - pointA.y * Math.sin(bodyA.angle)), y: bodyA.position.y + (pointA.x * Math.sin(bodyA.angle) + pointA.y * Math.cos(bodyA.angle)) }; else startPos = pointA;
                 if (bodyB) endPos = { x: bodyB.position.x + (pointB.x * Math.cos(bodyB.angle) - pointB.y * Math.sin(bodyB.angle)), y: bodyB.position.y + (pointB.x * Math.sin(bodyB.angle) + pointB.y * Math.cos(bodyB.angle)) }; else endPos = pointB;
                 ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(endPos.x, endPos.y);
            }
            ctx.strokeStyle = `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--accent-color-rgb')}, 0.7)`;
            ctx.lineWidth = 2; ctx.stroke();

            // 2. Render Bodies (same as before)
            for (let i = 0; i < allBodies.length; i += 1) { /* ... (same drawing logic) ... */
                 const body = allBodies[i];
                 if (body.isStatic && !body.render.visible) continue;
                 const vertices = body.vertices; const renderProps = body.renderProps || {};
                 ctx.beginPath(); ctx.moveTo(vertices[0].x, vertices[0].y);
                 for (let j = 1; j < vertices.length; j += 1) ctx.lineTo(vertices[j].x, vertices[j].y);
                 ctx.closePath();
                 ctx.fillStyle = renderProps.fillStyle || '#cccccc'; ctx.strokeStyle = renderProps.strokeStyle || '#555';
                 ctx.lineWidth = renderProps.lineWidth || 1; ctx.shadowColor = renderProps.shadowColor || 'transparent';
                 ctx.shadowBlur = renderProps.shadowBlur || 0; ctx.shadowOffsetX = renderProps.shadowOffsetX || 0;
                 ctx.shadowOffsetY = renderProps.shadowOffsetY || 0;
                 ctx.fill(); ctx.stroke();
                 ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
            }

            // 3. Render Collision Glows (same as before)
            const accentRGB = getComputedStyle(document.documentElement).getPropertyValue('--accent-color-rgb');
            activeCollisions = activeCollisions.filter(collision => { /* ... (same glow logic) ... */
                 const elapsedTime = timestamp - collision.startTime;
                 if (elapsedTime > GLOW_DURATION) return false;
                 const progress = elapsedTime / GLOW_DURATION;
                 const currentRadius = MAX_GLOW_RADIUS * (1 - progress);
                 const currentOpacity = 1 - progress;
                 const gradient = ctx.createRadialGradient(collision.x, collision.y, 0, collision.x, collision.y, currentRadius);
                 gradient.addColorStop(0, `rgba(${accentRGB}, ${currentOpacity * 0.8})`);
                 gradient.addColorStop(0.7, `rgba(${accentRGB}, ${currentOpacity * 0.3})`);
                 gradient.addColorStop(1, `rgba(${accentRGB}, 0)`);
                 ctx.fillStyle = gradient;
                 ctx.fillRect(collision.x - currentRadius, collision.y - currentRadius, currentRadius * 2, currentRadius * 2);
                 return true;
            });

            // 4. Render Constraint Drawing Feedback Line (same as before)
            if (activeTool === 'constraint' && constraintStartBody && constraintStartPoint) { /* ... (same drawing logic) ... */
                 const bodyA = constraintStartBody; const pointA = constraintStartPoint;
                 const startPos = { x: bodyA.position.x + (pointA.x * Math.cos(bodyA.angle) - pointA.y * Math.sin(bodyA.angle)), y: bodyA.position.y + (pointA.x * Math.sin(bodyA.angle) + pointA.y * Math.cos(bodyA.angle)) };
                 ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentMousePos.x, currentMousePos.y);
                 ctx.strokeStyle = `rgba(${accentRGB}, 0.5)`; ctx.lineWidth = 2;
                 ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }

            // 5. Render Breeze Tool Feedback Line
            if (activeTool === 'breeze' && breezeStartPos) {
                ctx.beginPath();
                ctx.moveTo(breezeStartPos.x, breezeStartPos.y);
                ctx.lineTo(currentMousePos.x, currentMousePos.y);
                ctx.strokeStyle = `rgba(${accentRGB}, 0.4)`;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 6]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

             // 6. Render Active Breeze Lines (Fading)
             activeBreezeVectors.forEach(breeze => {
                 const age = timestamp - breeze.timestamp;
                 const opacity = 1 - (age / BREEZE_FADE_DURATION);
                 ctx.beginPath();
                 ctx.moveTo(breeze.start.x, breeze.start.y);
                 ctx.lineTo(breeze.end.x, breeze.end.y);
                 ctx.strokeStyle = `rgba(${accentRGB}, ${opacity * 0.5})`; // Fading opacity
                 ctx.lineWidth = 4; // Slightly thicker
                 ctx.setLineDash([10, 8]);
                 ctx.stroke();
                 ctx.setLineDash([]);
             });


            // 7. Render Attractors
            attractors.forEach(attractor => {
                 const pulseProgress = (Math.sin(timestamp * ATTRACTOR_PULSE_SPEED + attractor.pulsePhase) + 1) / 2; // 0 to 1 sine wave
                 const radius = ATTRACTOR_MIN_RADIUS + pulseProgress * (ATTRACTOR_MAX_RADIUS - ATTRACTOR_MIN_RADIUS);
                 const opacity = 0.4 + pulseProgress * 0.3; // Pulse opacity slightly

                 ctx.beginPath();
                 ctx.arc(attractor.x, attractor.y, radius, 0, Math.PI * 2);
                 ctx.strokeStyle = `rgba(${accentRGB}, ${opacity})`;
                 ctx.lineWidth = 2;
                 // Optional fill:
                 // ctx.fillStyle = `rgba(${accentRGB}, ${opacity * 0.1})`;
                 // ctx.fill();
                 ctx.stroke();
            });


            requestAnimationFrame(renderLoop);
        }

        // --- Start Setup ---
        window.onload = setup;

    </script>

</body>
</html>